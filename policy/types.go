/*
 Copyright 2024 The OSCAL Compass Authors
 SPDX-License-Identifier: Apache-2.0
*/

package policy

import (
	"time"

	"github.com/oscal-compass/oscal-sdk-go/extensions"
	"github.com/revanite-io/sci/layer2"
	"github.com/revanite-io/sci/layer4"
)

// Result represents the kind of Result statuses.
type Result uint

const (
	ResultInvalid Result = iota
	ResultFail
	ResultError
	ResultPass
	ResultWarning
)

// String prints a string representation of the Result.
func (r Result) String() string {
	switch r {
	case ResultInvalid:
		return "INVALID"
	case ResultFail:
		return "fail"
	case ResultError:
		return "error"
	case ResultPass:
		return "pass"
	case ResultWarning:
		return "warning"
	default:
		panic("invalid result")
	}
}

// Property define an instance of a key/value that can be
// converted to an OSCAL Property type.
type Property struct {
	Name  string
	Value string
}

// Link represents a link to an external artifact
// that can be converted an OSCAL Link type.
type Link struct {
	Description string
	Href        string
}

// Subject represents a specific resource that is evaluated
// by the policy and policy outcome information. This can be converted to
// an OSCAL Subject type.
type Subject struct {
	Title       string
	Type        string
	ResourceID  string
	Result      Result
	EvaluatedOn time.Time
	Reason      string
	Props       []Property
}

// ObservationByCheck represents the assessment outcome and all associated data
// from a single Check on applicable subjects.
type ObservationByCheck struct {
	Title             string
	Description       string
	CheckID           string
	RequirementID     string
	Methods           []string
	Subjects          []Subject
	Collected         time.Time
	Props             []Property
	RelevantEvidences []Link
}

// PVPResult represent a set of policy results generated by a PVP.
type PVPResult struct {
	ObservationsByCheck []ObservationByCheck
	Links               []Link
}

// Policy represents a list of RuleSets.
type Policy []extensions.RuleSet

// Config is a WIP policy implementation while SCI Layer 3 is under development.
// For prototyping there is 1:1 relationship
// between the target and validator.
type Config struct {
	Catalogs []CatalogRef `yaml:"catalogs"`
}

type CatalogRef struct {
	CatalogID string `yaml:"id"`
	Catalog   *layer2.Layer2
	// Lazy loading
	Loader CatalogLoader
	Plans  []PlanRef `yaml:"services"`
}

type CatalogLoader func() (*layer2.Layer2, error)

func (r *CatalogRef) Load() error {
	catalog, err := r.Loader()
	if err != nil {
		return err
	}
	r.Catalog = catalog
	return nil
}

type PlanRef struct {
	Service  string `yaml:"service"`
	PluginID string `yaml:"pluginID"`
	// Pre-run evaluation
	Plan *layer4.Layer4
	// Lazy loading
	Loader PlanLoader
}

type PlanLoader func() (*layer4.Layer4, error)

func (r *PlanRef) Load() error {
	plan, err := r.Loader()
	if err != nil {
		return err
	}
	r.Plan = plan
	return nil
}
